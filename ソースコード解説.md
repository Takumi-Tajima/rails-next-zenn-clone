# Next.jsのindex.tsxとArticleCard.tsxの関係性解説

## 全体像

このコードは、Rails APIから記事一覧を取得して、Next.jsのフロントエンドで表示する仕組みやで。
- `index.tsx`: トップページ全体を表示する親コンポーネント
- `ArticleCard.tsx`: 1つ1つの記事カードを表示する子コンポーネント

親が子を呼び出して使う、っちゅう関係性や。

---

## ArticleCard.tsx の詳細解説

まず、子コンポーネントから見ていくで。こっちの方がシンプルで理解しやすいからな。

### 1行目〜2行目: ライブラリのインポート

```tsx
import { Box, Card, CardContent, Typography } from '@mui/material'
```

**解説:**
- Material-UI (MUI) っちゅうUIライブラリから、よく使うコンポーネントをインポートしてるんや
- `Box`: レイアウト用のコンテナ(divみたいなもん)
- `Card`: カード型のUIコンポーネント
- `CardContent`: カードの中身を入れる部分
- `Typography`: テキスト表示用のコンポーネント

### 3行目〜7行目: 型定義

```tsx
type ArticleCardProps = {
  title: string
  fromToday: string
  userName: string
}
```

**解説:**
- TypeScriptの型定義や。このコンポーネントが受け取るプロパティ(props)の形を定義してるんや
- `title`: 記事のタイトル(文字列)
- `fromToday`: 投稿からの経過時間(例: "3日前")
- `userName`: 投稿したユーザーの名前(文字列)

### 9行目〜10行目: テキスト省略用の関数

```tsx
const omit = (text: string) => (len: number) => (ellipsis: string) =>
  text.length >= len ? text.slice(0, len - ellipsis.length) + ellipsis : text
```

**解説:**
- カリー化っちゅう関数型プログラミングのテクニックを使ってるんや
- 長いタイトルを切り詰めて「...」を付ける関数や
- 使い方: `omit(テキスト)(最大文字数)(省略記号)`
- 例: `omit("これは長いタイトルです")(10)("...")` → `"これは長いタ..."`
- 条件分岐:
  - `text.length >= len` やったら → 切り詰めて省略記号を付ける
  - そうやなかったら → そのまま返す

### 12行目〜35行目: メインのコンポーネント

```tsx
const ArticleCard = (props: ArticleCardProps) => {
  return (
    <Card>
      <CardContent>
```

**解説:**
- `ArticleCard`っちゅう関数コンポーネントを定義してるんや
- `props: ArticleCardProps`で、さっき定義した型のpropsを受け取る
- `<Card>`と`<CardContent>`でカードのUIを作ってる

### 16行目〜27行目: タイトル部分

```tsx
<Typography
  component="h3"
  sx={{
    mb: 2,
    minHeight: 48,
    fontSize: 16,
    fontWeight: 'bold',
    lineHeight: 1.5,
  }}
>
  {omit(props.title)(45)('...')}
</Typography>
```

**解説:**
- `Typography`で見出しを表示してるんや
- `component="h3"`: HTML的にはh3タグとして出力される
- `sx={{...}}`: MUIのスタイル記法や。CSSのプロパティを書ける
  - `mb: 2`: margin-bottomを2単位(通常8px × 2 = 16px)
  - `minHeight: 48`: 最小の高さを48px確保(タイトルが短くても高さを揃える)
  - `fontSize: 16`: フォントサイズ16px
  - `fontWeight: 'bold'`: 太字
  - `lineHeight: 1.5`: 行の高さを1.5倍
- `{omit(props.title)(45)('...')}`: タイトルを45文字で切り詰める

### 28行目〜31行目: ユーザー名と日付部分

```tsx
<Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
  <Typography sx={{ fontSize: 12 }}>{props.userName}</Typography>
  <Typography sx={{ fontSize: 12 }}>{props.fromToday}</Typography>
</Box>
```

**解説:**
- `Box`でフレックスボックスのコンテナを作ってるんや
- `display: 'flex'`: 横並びレイアウト
- `justifyContent: 'space-between'`: 左右に要素を配置(間にスペースを作る)
- 左側にユーザー名、右側に経過時間を表示
- どっちも`fontSize: 12`で12pxの小さめのフォント

### 37行目: エクスポート

```tsx
export default ArticleCard
```

**解説:**
- このコンポーネントを他のファイルから使えるようにエクスポートしてるんや
- `default`が付いてるから、インポート時に好きな名前で読み込める

---

## index.tsx の詳細解説

次は親コンポーネントや。こっちがメインのページやな。

### 1行目〜7行目: ライブラリのインポート

```tsx
import { Box, Grid, Container } from '@mui/material'
import camelcaseKeys from 'camelcase-keys'
import type { NextPage } from 'next'
import Link from 'next/link'
import useSWR from 'swr'
import ArticleCard from '@/components/ArticleCard'
import { fetcher } from '@/utils'
```

**解説:**
それぞれのインポートの意味を説明するで:

1. `@mui/material`: MUIのレイアウトコンポーネント
   - `Box`: 汎用コンテナ
   - `Grid`: グリッドレイアウト(カードを並べるのに使う)
   - `Container`: コンテンツの幅を制限するコンテナ

2. `camelcaseKeys`: オブジェクトのキーをキャメルケースに変換するライブラリ
   - Rails APIは`snake_case`(例: `created_at`)を返すことが多い
   - JavaScriptでは`camelCase`(例: `createdAt`)が一般的
   - この変換をしてくれるんや

3. `NextPage`: Next.jsのページコンポーネントの型定義

4. `Link`: Next.jsのルーティング用コンポーネント(ページ遷移に使う)

5. `useSWR`: データ取得用のReact Hooksライブラリ
   - SWR = "Stale-While-Revalidate"(古いデータを表示しつつ、裏で新しいデータを取得する戦略)
   - キャッシュ、再検証、エラーハンドリングを自動でやってくれる

6. `ArticleCard`: さっき見た子コンポーネント

7. `fetcher`: API通信用のユーティリティ関数(別ファイルで定義されてる)

### 9行目〜17行目: 型定義

```tsx
type ArticleProps = {
  id: number
  title: string
  createdAt: string
  fromToday: string
  user: {
    name: string
  }
}
```

**解説:**
- 1つの記事データの型を定義してるんや
- RailsのAPIから返ってくるデータの形に合わせてる
- `user`がネストしたオブジェクトになってることに注目や
  - `user.name`でユーザー名を取得できる
- **注意**: `ArticleCard`のpropsとは別の型や(こっちの方が情報が多い)

### 19行目〜24行目: コンポーネントの定義とデータ取得

```tsx
const Index: NextPage = () => {
  const url = 'http://localhost:3000/api/v1/articles'

  const { data, error } = useSWR(url, fetcher)
  if (error) return <div>An error has occurred.</div>
  if (!data) return <div>Loading...</div>
```

**解説:**

1. `const Index: NextPage = () => {`:
   - `Index`っちゅう名前のページコンポーネントを定義
   - `NextPage`型を使ってる

2. `const url = 'http://localhost:3000/api/v1/articles'`:
   - Rails APIのエンドポイントURLを定義
   - ローカル開発環境のURL(Rails側は3000番ポート)

3. `const { data, error } = useSWR(url, fetcher)`:
   - useSWRでデータを取得
   - `data`: 取得成功時のデータ
   - `error`: エラー発生時のエラーオブジェクト
   - `fetcher`でAPIを叩く

4. `if (error) return <div>An error has occurred.</div>`:
   - エラーが発生したらエラーメッセージを表示して終了

5. `if (!data) return <div>Loading...</div>`:
   - データがまだ取得できてなかったら「読み込み中」を表示
   - これを「アーリーリターン」っちゅう

### 26行目: データの変換

```tsx
const articles = camelcaseKeys(data.articles)
```

**解説:**
- `data.articles`にAPIから取得した記事の配列が入ってる
- `camelcaseKeys`で全部のキーをキャメルケースに変換
- 例:
  - 変換前: `{ created_at: "2024-01-01", user_name: "太郎" }`
  - 変換後: `{ createdAt: "2024-01-01", userName: "太郎" }`

### 28行目〜45行目: UI部分

```tsx
return (
  <Box sx={{ backgroundColor: '#e6f2ff', minHeight: '100vh' }}>
    <Container maxWidth="md" sx={{ pt: 6 }}>
      <Grid container spacing={4}>
```

**解説:**

1. `<Box sx={{ backgroundColor: '#e6f2ff', minHeight: '100vh' }}>`:
   - 画面全体を包むコンテナ
   - `backgroundColor`: 薄い青色の背景
   - `minHeight: '100vh'`: 最小の高さを画面の高さ100%(viewport height)にする

2. `<Container maxWidth="md" sx={{ pt: 6 }}>`:
   - コンテンツの幅を制限するコンテナ
   - `maxWidth="md"`: 中くらいの幅(通常900px)
   - `pt: 6`: padding-topを6単位(8px × 6 = 48px)

3. `<Grid container spacing={4}>`:
   - グリッドレイアウトの親要素
   - `container`: グリッドコンテナとして動作
   - `spacing={4}`: 各グリッドアイテム間のスペースを4単位(32px)

### 32行目〜42行目: 記事のループ表示

```tsx
{articles.map((article: ArticleProps, i: number) => (
  <Grid key={i} item xs={12} md={6}>
    <Link href={'/articles/' + article.id}>
      <ArticleCard
        title={article.title}
        fromToday={article.fromToday}
        userName={article.user.name}
      />
    </Link>
  </Grid>
))}
```

**解説:**

1. `articles.map((article: ArticleProps, i: number) => (`:
   - 配列の各要素をループ処理
   - `article`: 1つ1つの記事データ
   - `i`: インデックス番号(0, 1, 2, ...)

2. `<Grid key={i} item xs={12} md={6}>`:
   - グリッドの1つのアイテム
   - `key={i}`: Reactが要素を識別するためのキー(本当は`article.id`の方が良い)
   - `item`: グリッドアイテムとして動作
   - `xs={12}`: 小さい画面では横幅100%(1列)
   - `md={6}`: 中くらい以上の画面では横幅50%(2列)

3. `<Link href={'/articles/' + article.id}>`:
   - Next.jsのリンクコンポーネント
   - クリックしたら記事詳細ページに遷移
   - 例: `/articles/1`, `/articles/2`

4. `<ArticleCard ... />`:
   - さっき見た子コンポーネントを呼び出してる
   - 親から子にpropsを渡してる:
     - `title={article.title}`: 記事タイトル
     - `fromToday={article.fromToday}`: 経過時間
     - `userName={article.user.name}`: ユーザー名(ネストしたオブジェクトから取得)

---

## 親子関係の整理

### データの流れ

```
Rails API (localhost:3000)
  ↓ (useSWRで取得)
index.tsx (親コンポーネント)
  ↓ (propsで渡す)
ArticleCard.tsx (子コンポーネント)
```

### propsの変換

親が持ってるデータ(`ArticleProps`型):
```typescript
{
  id: 1,
  title: "記事のタイトル",
  createdAt: "2024-01-01",
  fromToday: "3日前",
  user: {
    name: "山田太郎"
  }
}
```

↓ 必要な部分だけを抽出して子に渡す

子が受け取るデータ(`ArticleCardProps`型):
```typescript
{
  title: "記事のタイトル",
  fromToday: "3日前",
  userName: "山田太郎"  // user.nameから取得
}
```

### レスポンシビリティ(責任範囲)

**親コンポーネント(index.tsx)の責任:**
- APIからデータを取得する
- データをキャメルケースに変換する
- エラーハンドリングとローディング表示
- 全体のレイアウト(背景色、グリッド配置)
- ページ遷移のリンク設定

**子コンポーネント(ArticleCard.tsx)の責任:**
- 1つの記事カードの見た目を作る
- タイトルの長さを調整する
- カード内のレイアウト(タイトル、ユーザー名、日付)

この役割分担で、コードの再利用性と保守性が高まるんや。

---

## エラーの可能性

このコードがエラーになる可能性がある箇所:

### 1. API接続エラー
- Rails側が起動してない
- ポート番号が違う
- CORSの設定が足りない

### 2. データ構造の不一致
- APIが返すデータの構造が`ArticleProps`と違う
- `data.articles`が存在しない(多分これが原因)
- `user.name`が存在しない

### 3. インポートエラー
- `@/utils`の`fetcher`が存在しない
- パスエイリアス(`@`)の設定が足りない

### 4. 型エラー
- `camelcaseKeys`の型定義が合ってない
- `ArticleProps`と実際のデータが合ってない

---

## まとめ

このコードの構造はこうや:

1. **ArticleCard.tsx**: 記事カード1枚分のUIコンポーネント
   - propsで`title`, `fromToday`, `userName`を受け取る
   - カード型のデザインで表示
   - 長いタイトルは省略

2. **index.tsx**: トップページ全体
   - Rails APIから記事一覧を取得
   - グリッドレイアウトで複数のカードを表示
   - 各カードをクリックすると記事詳細ページに遷移
   - `ArticleCard`を複数呼び出して使う

**関係性**: 親(index.tsx)が子(ArticleCard.tsx)を呼び出して、必要なデータをpropsで渡す、っちゅうReactの基本パターンや。

エラーの原因を特定するには、実際のエラーメッセージを見る必要があるで!
